<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>AR — Bouton dans l'espace (single file)</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial}
    #ui{position:fixed;left:0;right:0;top:0;bottom:0;pointer-events:none}
    /* Logo fixe en haut droit */
    #logo{position:fixed;top:12px;right:12px;z-index:999;pointer-events:auto}
    #logo img{height:48px;width:auto;display:block}
    /* Bouton de contrôle AR (non spatial) */
    #startAR{position:fixed;left:12px;bottom:12px;z-index:999;pointer-events:auto;padding:10px 14px;border-radius:8px;border:none;background:#0b5cff;color:white;font-weight:600}
    #message{position:fixed;left:12px;bottom:80px;z-index:999;color:white;background:rgba(0,0,0,0.5);padding:8px 10px;border-radius:6px}
    /* Canvas full-screen for three.js renderer */
    canvas{display:block}
  </style>
</head>
<body>
  <!-- Logo fixe (remplacez src par votre image) -->
  <div id="logo"><img src="LogoAR.png" alt="Logo" /></div>

  <!-- Bouton pour démarrer la session AR -->
  <button id="startAR">Démarrer AR</button>
  <div id="message">Appuyez sur "Démarrer AR" puis pointez votre appareil vers une surface.</div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
  import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';

  let camera, scene, renderer;
  let reticle, controller;
  let placed = false;

  init();

  function init(){
    const container = document.createElement('div');
    document.body.appendChild(container);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    container.appendChild(renderer.domElement);

    // Lumière
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    // Reticle: indicateur de position sur la surface détectée
    reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI/2),
      new THREE.MeshBasicMaterial({color:0x00ffcc})
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Controller pour les interactions et hit-test
    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    window.addEventListener('resize', onWindowResize);

    // Start AR button (also uses ARButton as fallback UI)
    const startBtn = document.getElementById('startAR');
    startBtn.addEventListener('click', async ()=>{
      if (navigator.xr && navigator.xr.isSessionSupported){
        const supported = await navigator.xr.isSessionSupported('immersive-ar');
        if (supported){
          const sessionInit = { requiredFeatures: ['hit-test','dom-overlay'], domOverlay: { root: document.body } };
          const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
          renderer.xr.setSession(session);

          // When session starts, set up hit testing reference space
          setupHitTest(session);
          document.getElementById('message').style.display = 'none';
          startBtn.style.display = 'none';
        } else {
          alert('WebXR AR non supporté sur cet appareil / navigateur. Utilisez Chrome sur Android avec ARCore ou un navigateur compatible.');
        }
      } else {
        // Fallback using ARButton (some browsers need this script)
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));
      }
    });
  }

  let xrRefSpace = null;
  let hitTestSource = null;

  async function setupHitTest(session){
    xrRefSpace = await session.requestReferenceSpace('local');
    const viewerSpace = await session.requestReferenceSpace('viewer');
    hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

    session.addEventListener('end', ()=>{
      hitTestSource = null;
      xrRefSpace = null;
      placed = false;
      // show start UI again
      document.getElementById('startAR').style.display = 'block';
      document.getElementById('message').style.display = 'block';
    });

    renderer.setAnimationLoop(render);
  }

  // Crée un matériau à partir d'un canvas pour ressembler à un bouton
  function createButtonTexture(text){
    const c = document.createElement('canvas');
    c.width = 512; c.height = 256;
    const ctx = c.getContext('2d');
    // fond semi-transparent
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    roundRect(ctx, 6,6, c.width-12, c.height-12, 28);
    ctx.fill();
    // texte
    ctx.fillStyle = '#0b5cff';
    ctx.font = 'bold 42px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(text, c.width/2, c.height/2 + 12);
    return new THREE.CanvasTexture(c);
  }

  // utilitaire: dessin arrondi
  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Lors d'un "select" (tap) si l'objet spatial existe, on ouvre le lien
  function onSelect(){
    if (placed && spatialObject){
      // Remplacez par le lien voulu
      const link = 'https://example.com';
      window.open(link, '_blank');
    }
  }

  let spatialObject = null;
  function placeSpatialButton(xrPose){
    if (placed) return;
    const texture = createButtonTexture('Visiter le lien');
    const material = new THREE.MeshBasicMaterial({ map:texture, transparent:true });
    const geometry = new THREE.PlaneGeometry(0.5, 0.25); // taille en mètres
    spatialObject = new THREE.Mesh(geometry, material);
    spatialObject.position.setFromMatrixPosition(xrPose.transform.matrix ? new THREE.Matrix4().fromArray(xrPose.transform.matrix) : new THREE.Vector3());
    // orienter vers la caméra
    const camPos = new THREE.Vector3();
    camera.getWorldPosition(camPos);
    spatialObject.lookAt(camPos);
    scene.add(spatialObject);
    placed = true;

    // rendre le maillage cliquable: nous utiliserons raycast depuis le controller
  }

  function render(timestamp, frame){
    if (frame){
      const session = renderer.xr.getSession();
      const refSpace = xrRefSpace;
      const viewerPose = frame.getViewerPose(refSpace);

      if (hitTestSource && viewerPose){
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if (hitTestResults.length > 0){
          const hit = hitTestResults[0];
          const pose = hit.getPose(refSpace);
          // montrer le reticle
          reticle.visible = true;
          reticle.matrix.fromArray(pose.transform.matrix);

          // placer automatiquement le bouton à la première détection
          if (!placed){
            placeSpatialButton(pose);
            // cacher le reticle si on veut
            reticle.visible = false;
          }
        } else {
          reticle.visible = false;
        }
      }

      // gérer les interactions (tap) via controller raycasting
      if (placed && controller){
        const tempMatrix = new THREE.Matrix4();
        tempMatrix.identity().extractRotation(controller.matrixWorld);

        const raycaster = new THREE.Raycaster();
        const origin = new THREE.Vector3();
        controller.getWorldPosition(origin);
        const direction = new THREE.Vector3(0,0,-1).applyMatrix4(tempMatrix);
        raycaster.set(origin, direction.normalize());
        const intersects = raycaster.intersectObject(spatialObject, true);
        // Si intersecté et bouton pressé (select event triggers window.open)
        // Nous pourrions ajouter un feedback visuel
        if (intersects.length > 0){
          // optionnel: agrandir légèrement
          spatialObject.scale.set(1.05,1.05,1.05);
        } else {
          if (spatialObject) spatialObject.scale.set(1,1,1);
        }
      }
    }

    renderer.render(scene, camera);
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // --- IMPORTANT : Accessibility & fallback ---
  // If user wants the button to appear even without AR support, we can show a floating 2D button
  (function add2Dalt(){
    const altBtn = document.createElement('a');
    altBtn.href = 'https://example.com';
    altBtn.textContent = 'Ouvrir le lien (2D)';
    altBtn.style.position = 'fixed';
    altBtn.style.left = '50%';
    altBtn.style.transform = 'translateX(-50%)';
    altBtn.style.bottom = '12px';
    altBtn.style.background = '#fff';
    altBtn.style.padding = '8px 12px';
    altBtn.style.borderRadius = '8px';
    altBtn.style.zIndex = '998';
    altBtn.style.textDecoration = 'none';
    altBtn.style.color = '#0b5cff';
    document.body.appendChild(altBtn);
  })();

  </script>
</body>
</html>
