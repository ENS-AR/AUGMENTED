<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Livre et Cube 3D sur espace réel</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: #000;
  }
  video {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 1;
  }
  canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
  }
  /* --- Section Précharge --- */
  #preload {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #1a1a1a; 
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999; 
    opacity: 1;
    transition: opacity 1s ease-out;
  }
  #preload.hidden {
    opacity: 0;
    pointer-events: none;
  }
  #preload img {
    height: 150px; 
    width: 150px;
    object-fit: contain;
    animation: pulse 1.5s infinite alternate; 
  }
  @keyframes pulse {
    from { transform: scale(1); opacity: 0.8; }
    to { transform: scale(1.1); opacity: 1; }
  }
  /* -------------------------- */
  #ui-logo {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 3;
  }
  #ui-logo img {
    height: 50px;
  }
  #error {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 10px 20px;
    border-radius: 10px;
    display: none;
    z-index: 4;
    font-family: sans-serif;
  }
</style>
</head>
<body>
  <div id="preload">
    <img src="LogoAr.png" alt="Chargement...">
  </div>

  <video id="camera" autoplay playsinline></video>
  <div id="ui-logo"><img src="LogoAr.png" alt="Logo"></div>
  <div id="error"></div>

<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

  const video = document.getElementById('camera');
  const errorMsg = document.getElementById('error');
  const preload = document.getElementById('preload'); 

  // --- Fonctions de gestion du chargement ---
  function hidePreload() {
    // S'assure que la vidéo est chargée et que Three.js est prêt
    if (video.readyState >= 3 && sceneObjectsGroup) { 
        preload.classList.add('hidden');
    }
  }

  // === 1. Ouvrir la caméra ===
  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });
      video.srcObject = stream;
      video.addEventListener('loadeddata', hidePreload);
    } catch (err) {
      errorMsg.textContent = "Erreur caméra : " + err.message;
      errorMsg.style.display = "block";
      hidePreload(); 
    }
  }
  startCamera();

  // === 2. Créer la scène Three.js ===
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.z = 2; // La caméra est le point de référence pour le monde

  const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.zIndex = 2;
  document.body.appendChild(renderer.domElement);
  
  // GROUPE PARENT pour tous les objets 3D (Permet de déplacer, zoomer, pivoter l'ensemble)
  const sceneObjectsGroup = new THREE.Group();
  scene.add(sceneObjectsGroup);
  
  // === 3. Lumière ===
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 1, 2);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));

  // ==========================================================
  // === 4. Objets 3D (Livre et Cube) ===
  // ==========================================================
  
  // --- A. Livre 3D (Identique) ---
  const coverMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const pageMaterial = new THREE.MeshStandardMaterial({ color: 0xfdf6e3 });
  const coverThickness = 0.05;
  const coverWidth = 1.2;
  const coverHeight = 0.8;
  const backCover = new THREE.Mesh( new THREE.BoxGeometry(coverWidth, coverHeight, coverThickness), coverMaterial );
  const pages = new THREE.Mesh( new THREE.BoxGeometry(coverWidth * 0.98, coverHeight * 0.95, coverThickness * 4), pageMaterial );
  pages.position.z = coverThickness * 2;
  const frontCover = new THREE.Mesh( new THREE.BoxGeometry(coverWidth, coverHeight, coverThickness), coverMaterial );
  frontCover.position.z = coverThickness * 4;
  
  const book = new THREE.Group();
  book.add(backCover);
  book.add(pages);
  book.add(frontCover);
  
  book.position.set(-1, 0, 0); // Positionner le livre à gauche
  book.rotation.x = 0.2; 
  sceneObjectsGroup.add(book);

  // --- B. Cube Blanc (Nouveau) ---
  const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const cube = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.5, 0.5), // Cube de 0.5 unités
      cubeMaterial
  );
  cube.position.set(1, 0, 0); // Positionner le cube à droite
  sceneObjectsGroup.add(cube);
  
  // Cacher le preload une fois les objets 3D ajoutés
  hidePreload();

  // === 5. Animation ===
  let autoAngle = 0;
  function animate() {
    requestAnimationFrame(animate);
    
    // Rotation légère auto Sauf si un contrôle tactile est actif
    if (!isControlling) {
        autoAngle += 0.01;
        // Rotation sur le cube et le livre si non contrôlé
        cube.rotation.y += 0.01; 
        book.rotation.y = Math.sin(autoAngle) * 0.5; 
    }
    
    renderer.render(scene, camera);
  }
  animate();

  // === 6. Ajuster la taille de l’écran ===
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
  
  // ==========================================================
  // === 7. Contrôles Tactiles (Zoom/Rotation/Déplacement avec deux doigts) ===
  // ==========================================================
  let startDistance = 0;
  let isControlling = false;
  
  let previousTouchPosition = null;
  let initialRotationY = 0;
  let initialPosition = new THREE.Vector3(); // Pour la translation
  
  const MIN_SCALE = 0.5;
  const MAX_SCALE = 5.0;

  function getDistance(touches) {
    const dx = touches[0].pageX - touches[1].pageX;
    const dy = touches[0].pageY - touches[1].pageY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function getMidPoint(touches) {
      return {
          x: (touches[0].pageX + touches[1].pageX) / 2,
          y: (touches[0].pageY + touches[1].pageY) / 2
      };
  }
  
  // Convertit les coordonnées écran (pixels) en mouvement dans le monde 3D
  function screenToWorldDelta(deltaX, deltaY) {
    // Plus la caméra est loin, plus le mouvement doit être grand
    const sensitivity = sceneObjectsGroup.position.z * 0.002;
    return {
        worldX: deltaX * sensitivity * camera.aspect,
        worldY: -deltaY * sensitivity
    };
  }

  renderer.domElement.addEventListener('touchstart', (event) => {
    if (event.touches.length === 2) {
      event.preventDefault();
      isControlling = true;
      initialRotationY = sceneObjectsGroup.rotation.y;
      initialPosition.copy(sceneObjectsGroup.position); // Sauvegarder la position de départ
      
      // Zoom
      startDistance = getDistance(event.touches);
      
      // Rotation/Déplacement
      previousTouchPosition = getMidPoint(event.touches);
    }
  });

  renderer.domElement.addEventListener('touchmove', (event) => {
    if (event.touches.length === 2) {
      event.preventDefault();
      
      const currentTouchPosition = getMidPoint(event.touches);
      
      if (previousTouchPosition) {
          const deltaX = currentTouchPosition.x - previousTouchPosition.x;
          const deltaY = currentTouchPosition.y - previousTouchPosition.y;
          
          // --- Déplacer (Translation XY) ---
          if (event.ctrlKey) { // Optionnel: Utiliser une touche/un mode pour le déplacement
            const worldDelta = screenToWorldDelta(deltaX, deltaY);
            sceneObjectsGroup.position.x += worldDelta.worldX;
            sceneObjectsGroup.position.y += worldDelta.worldY;
          } 
          
          // --- Rotation (Pivoter) ---
          else {
              const rotationSensitivity = 0.005; 
              
              // Rotation autour de l'axe Y (horizontal)
              sceneObjectsGroup.rotation.y += deltaX * rotationSensitivity;
              
              // Rotation autour de l'axe X (vertical)
              sceneObjectsGroup.rotation.x += deltaY * rotationSensitivity;
          }

          previousTouchPosition = currentTouchPosition; 
      }
      
      // --- Zoom (Pincer/Écarter) ---
      const currentDistance = getDistance(event.touches);
      const scaleFactor = currentDistance / startDistance;
      let newScale = Math.min(Math.max(sceneObjectsGroup.scale.x * scaleFactor, MIN_SCALE), MAX_SCALE);
      sceneObjectsGroup.scale.set(newScale, newScale, newScale);
      
      // Mettre à jour la distance de départ pour un mouvement continu
      startDistance = currentDistance; 
    }
  });

  renderer.domElement.addEventListener('touchend', (event) => {
    if (event.touches.length === 0) {
      isControlling = false;
      startDistance = 0;
      previousTouchPosition = null;
    }
  });
</script>
</body>
</html>
