<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Livre 3D sur espace réel</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: #000;
  }
  video {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 1;
  }
  canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 2;
  }
  /* --- Section Précharge (Nouveau) --- */
  #preload {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #1a1a1a; /* Couleur de fond pour le preload */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999; /* Au-dessus de tout */
    opacity: 1;
    transition: opacity 1s ease-out; /* Effet de fondu */
  }
  #preload.hidden {
    opacity: 0;
    pointer-events: none; /* Désactive les interactions une fois invisible */
  }
  #preload img {
    max-width: 80%;
    max-height: 80%;
    /* Optionnel : petite animation du logo pendant le chargement */
    animation: pulse 1.5s infinite alternate; 
  }
  @keyframes pulse {
    from { transform: scale(1); }
    to { transform: scale(1.05); }
  }
  /* ------------------------------------ */
  #ui-logo {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 3;
  }
  #ui-logo img {
    height: 50px;
  }
  #error {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 10px 20px;
    border-radius: 10px;
    display: none;
    z-index: 4;
    font-family: sans-serif;
  }
</style>
</head>
<body>
  <div id="preload">
    <img src="LogoAr.png" alt="Chargement...">
  </div>

  <video id="camera" autoplay playsinline></video>
  <div id="ui-logo"><img src="LogoAr.png" alt="Logo"></div>
  <div id="error"></div>

<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

  const video = document.getElementById('camera');
  const errorMsg = document.getElementById('error');
  const preload = document.getElementById('preload'); // Nouvelle référence

  // --- Fonctions de gestion du chargement ---
  function hidePreload() {
    // S'assure que la vidéo est chargée et que Three.js est prêt
    if (video.readyState >= 3 && book) { 
        preload.classList.add('hidden');
    }
  }

  // === 1. Ouvrir la caméra ===
  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });
      video.srcObject = stream;
      video.addEventListener('loadeddata', hidePreload); // Cacher au chargement de la caméra
    } catch (err) {
      errorMsg.textContent = "Erreur caméra : " + err.message;
      errorMsg.style.display = "block";
      hidePreload(); // Cacher le preload même en cas d'erreur
    }
  }
  startCamera();

  // === 2. Créer la scène Three.js ===
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.z = 2;

  const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.zIndex = 2; // S'assurer que le canvas est au-dessus de la vidéo
  document.body.appendChild(renderer.domElement);
  
  // === 3. Lumière ===
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(1, 1, 2);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));

  // === 4. Créer un livre 3D (2 couvertures + pages) ===
  const coverMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const pageMaterial = new THREE.MeshStandardMaterial({ color: 0xfdf6e3 });

  const coverThickness = 0.05;
  const coverWidth = 1.2;
  const coverHeight = 0.8;

  // Couverture arrière
  const backCover = new THREE.Mesh(
    new THREE.BoxGeometry(coverWidth, coverHeight, coverThickness),
    coverMaterial
  );
  backCover.position.z = 0;

  // Pages
  const pages = new THREE.Mesh(
    new THREE.BoxGeometry(coverWidth * 0.98, coverHeight * 0.95, coverThickness * 4),
    pageMaterial
  );
  pages.position.z = coverThickness * 2;

  // Couverture avant
  const frontCover = new THREE.Mesh(
    new THREE.BoxGeometry(coverWidth, coverHeight, coverThickness),
    coverMaterial
  );
  frontCover.position.z = coverThickness * 4;

  // Groupe "livre"
  const book = new THREE.Group();
  book.add(backCover);
  book.add(pages);
  book.add(frontCover);
  scene.add(book);
  
  book.rotation.x = 0.2; // Position initiale
  book.scale.set(1, 1, 1); // Échelle initiale
  
  // Cacher le preload une fois l'objet 3D ajouté à la scène
  hidePreload();

  // === 5. Animation du livre (rotation légère automatique) ===
  let autoAngle = 0;
  function animate() {
    requestAnimationFrame(animate);
    // Rotation légère auto Sauf si un contrôle tactile est actif
    if (!isControlling) {
        autoAngle += 0.01;
        book.rotation.y = Math.sin(autoAngle) * 0.5 + initialRotationY; 
    }
    
    renderer.render(scene, camera);
  }
  animate();

  // === 6. Ajuster la taille de l’écran ===
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
  
  // ==========================================================
  // === 7. Contrôles Tactiles (Zoom/Rotation avec deux doigts) (Nouveau) ===
  // ==========================================================
  let startDistance = 0;
  let isControlling = false; // Indique si un mouvement tactile est en cours
  
  let previousTouchPosition = null;
  let initialRotationY = 0; // Stocker la rotation de base pour la combiner avec la rotation auto
  
  const MIN_SCALE = 0.5;
  const MAX_SCALE = 3.0;

  function getDistance(touches) {
    const dx = touches[0].pageX - touches[1].pageX;
    const dy = touches[0].pageY - touches[1].pageY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function getMidPoint(touches) {
      return {
          x: (touches[0].pageX + touches[1].pageX) / 2,
          y: (touches[0].pageY + touches[1].pageY) / 2
      };
  }

  renderer.domElement.addEventListener('touchstart', (event) => {
    if (event.touches.length === 2) {
      event.preventDefault();
      isControlling = true;
      initialRotationY = book.rotation.y; // Capture la rotation actuelle
      
      // Zoom
      startDistance = getDistance(event.touches);
      
      // Rotation
      previousTouchPosition = getMidPoint(event.touches);
    }
  });

  renderer.domElement.addEventListener('touchmove', (event) => {
    if (event.touches.length === 2) {
      event.preventDefault();
      
      // --- Zoom (Pincer/Écarter) ---
      const currentDistance = getDistance(event.touches);
      const scaleFactor = currentDistance / startDistance;
      let newScale = Math.min(Math.max(book.scale.x * scaleFactor, MIN_SCALE), MAX_SCALE);
      book.scale.set(newScale, newScale, newScale);
      
      // Mettre à jour la distance de départ pour un mouvement continu
      startDistance = currentDistance; 

      // --- Rotation (Pivoter avec 2 doigts) ---
      const currentTouchPosition = getMidPoint(event.touches);
      
      if (previousTouchPosition) {
          // Calculer le changement horizontal (rotation Y) et vertical (rotation X)
          const deltaX = currentTouchPosition.x - previousTouchPosition.x;
          const deltaY = currentTouchPosition.y - previousTouchPosition.y;
          
          // La sensibilité peut être ajustée (diviser par un nombre plus grand pour moins de rotation)
          const sensitivity = 0.005; 
          
          // Rotation autour de l'axe Y (horizontal)
          book.rotation.y += deltaX * sensitivity;
          
          // Rotation autour de l'axe X (vertical)
          book.rotation.x += deltaY * sensitivity;

          // Limiter la rotation X pour éviter que le livre ne soit à l'envers
          // book.rotation.x = Math.min(Math.max(book.rotation.x, -Math.PI / 2), Math.PI / 2);
          
          previousTouchPosition = currentTouchPosition; // Mettre à jour la position
          
          // Réinitialiser la rotation auto pour repartir de la rotation manuelle
          autoAngle = book.rotation.y;
          initialRotationY = 0;
      }
    }
  });

  renderer.domElement.addEventListener('touchend', (event) => {
    if (event.touches.length === 0) {
      isControlling = false;
      startDistance = 0;
      previousTouchPosition = null;
    }
  });
</script>
</body>
</html>
